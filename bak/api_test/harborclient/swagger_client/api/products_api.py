# coding: utf-8

"""
    Harbor API

    These APIs provide services for manipulating Harbor project.  # noqa: E501

    OpenAPI spec version: 1.6.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class ProductsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def configurations_get(self, **kwargs):  # noqa: E501
        """Get system configurations.  # noqa: E501

        This endpoint is for retrieving system configurations that only provides for admin user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.configurations_get(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ConfigurationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = False
        if kwargs.get('async'):
            return self.configurations_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.configurations_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def configurations_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get system configurations.  # noqa: E501

        This endpoint is for retrieving system configurations that only provides for admin user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.configurations_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ConfigurationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method configurations_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/configurations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigurationsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def configurations_put(self, configurations, **kwargs):  # noqa: E501
        """Modify system configurations.  # noqa: E501

        This endpoint is for modifying system configurations that only provides for admin user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.configurations_put(configurations, async=True)
        >>> result = thread.get()

        :param async bool
        :param Configurations configurations: The configuration map can contain a subset of the attributes of the schema, which are to be updated. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.configurations_put_with_http_info(configurations, **kwargs)  # noqa: E501
        else:
            (data) = self.configurations_put_with_http_info(configurations, **kwargs)  # noqa: E501
            return data

    def configurations_put_with_http_info(self, configurations, **kwargs):  # noqa: E501
        """Modify system configurations.  # noqa: E501

        This endpoint is for modifying system configurations that only provides for admin user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.configurations_put_with_http_info(configurations, async=True)
        >>> result = thread.get()

        :param async bool
        :param Configurations configurations: The configuration map can contain a subset of the attributes of the schema, which are to be updated. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['configurations']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method configurations_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'configurations' is set
        if ('configurations' not in params or
                params['configurations'] is None):
            raise ValueError("Missing the required parameter `configurations` when calling `configurations_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'configurations' in params:
            body_params = params['configurations']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/configurations', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def configurations_reset_post(self, **kwargs):  # noqa: E501
        """Reset system configurations.  # noqa: E501

        Reset system configurations from environment variables. Can only be accessed by admin user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.configurations_reset_post(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.configurations_reset_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.configurations_reset_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def configurations_reset_post_with_http_info(self, **kwargs):  # noqa: E501
        """Reset system configurations.  # noqa: E501

        Reset system configurations from environment variables. Can only be accessed by admin user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.configurations_reset_post_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method configurations_reset_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/configurations/reset', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def email_ping_post(self, **kwargs):  # noqa: E501
        """Test connection and authentication with email server.  # noqa: E501

        Test connection and authentication with email server.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.email_ping_post(async=True)
        >>> result = thread.get()

        :param async bool
        :param EmailServerSetting settings: Email server settings, if some of the settings are not assigned, they will be read from system configuration.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.email_ping_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.email_ping_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def email_ping_post_with_http_info(self, **kwargs):  # noqa: E501
        """Test connection and authentication with email server.  # noqa: E501

        Test connection and authentication with email server.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.email_ping_post_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param EmailServerSetting settings: Email server settings, if some of the settings are not assigned, they will be read from system configuration.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['settings']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method email_ping_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'settings' in params:
            body_params = params['settings']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/email/ping', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def internal_syncregistry_post(self, **kwargs):  # noqa: E501
        """Sync repositories from registry to DB.  # noqa: E501

        This endpoint is for syncing all repositories of registry with database.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.internal_syncregistry_post(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.internal_syncregistry_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.internal_syncregistry_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def internal_syncregistry_post_with_http_info(self, **kwargs):  # noqa: E501
        """Sync repositories from registry to DB.  # noqa: E501

        This endpoint is for syncing all repositories of registry with database.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.internal_syncregistry_post_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method internal_syncregistry_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/internal/syncregistry', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def jobs_replication_get(self, policy_id, **kwargs):  # noqa: E501
        """List filters jobs according to the policy and repository  # noqa: E501

        This endpoint let user list filters jobs according to the policy and repository. (if start_time and end_time are both null, list jobs of last 10 days)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.jobs_replication_get(policy_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int policy_id: The ID of the policy that triggered this job. (required)
        :param int num: The return list length number.
        :param int end_time: The end time of jobs done. (Timestamp)
        :param int start_time: The start time of jobs. (Timestamp)
        :param str repository: The respond jobs list filter by repository name.
        :param str status: The respond jobs list filter by status.
        :param int page: The page nubmer, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[JobStatus]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.jobs_replication_get_with_http_info(policy_id, **kwargs)  # noqa: E501
        else:
            (data) = self.jobs_replication_get_with_http_info(policy_id, **kwargs)  # noqa: E501
            return data

    def jobs_replication_get_with_http_info(self, policy_id, **kwargs):  # noqa: E501
        """List filters jobs according to the policy and repository  # noqa: E501

        This endpoint let user list filters jobs according to the policy and repository. (if start_time and end_time are both null, list jobs of last 10 days)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.jobs_replication_get_with_http_info(policy_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int policy_id: The ID of the policy that triggered this job. (required)
        :param int num: The return list length number.
        :param int end_time: The end time of jobs done. (Timestamp)
        :param int start_time: The start time of jobs. (Timestamp)
        :param str repository: The respond jobs list filter by repository name.
        :param str status: The respond jobs list filter by status.
        :param int page: The page nubmer, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[JobStatus]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['policy_id', 'num', 'end_time', 'start_time', 'repository', 'status', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method jobs_replication_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'policy_id' is set
        if ('policy_id' not in params or
                params['policy_id'] is None):
            raise ValueError("Missing the required parameter `policy_id` when calling `jobs_replication_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'policy_id' in params:
            query_params.append(('policy_id', params['policy_id']))  # noqa: E501
        if 'num' in params:
            query_params.append(('num', params['num']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501
        if 'repository' in params:
            query_params.append(('repository', params['repository']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/jobs/replication', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[JobStatus]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def jobs_replication_id_delete(self, id, **kwargs):  # noqa: E501
        """Delete specific ID job.  # noqa: E501

        This endpoint is aimed to remove specific ID job from jobservice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.jobs_replication_id_delete(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: Delete job ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.jobs_replication_id_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.jobs_replication_id_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def jobs_replication_id_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete specific ID job.  # noqa: E501

        This endpoint is aimed to remove specific ID job from jobservice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.jobs_replication_id_delete_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: Delete job ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method jobs_replication_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `jobs_replication_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/jobs/replication/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def jobs_replication_id_log_get(self, id, **kwargs):  # noqa: E501
        """Get job logs.  # noqa: E501

        This endpoint let user search job logs filtered by specific ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.jobs_replication_id_log_get(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: Relevant job ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.jobs_replication_id_log_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.jobs_replication_id_log_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def jobs_replication_id_log_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get job logs.  # noqa: E501

        This endpoint let user search job logs filtered by specific ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.jobs_replication_id_log_get_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: Relevant job ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method jobs_replication_id_log_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `jobs_replication_id_log_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/jobs/replication/{id}/log', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def jobs_replication_put(self, policyinfo, **kwargs):  # noqa: E501
        """Update status of jobs. Only stop is supported for now.  # noqa: E501

        The endpoint is used to stop the replication jobs of a policy.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.jobs_replication_put(policyinfo, async=True)
        >>> result = thread.get()

        :param async bool
        :param UpdateJobs policyinfo: The policy ID and status. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.jobs_replication_put_with_http_info(policyinfo, **kwargs)  # noqa: E501
        else:
            (data) = self.jobs_replication_put_with_http_info(policyinfo, **kwargs)  # noqa: E501
            return data

    def jobs_replication_put_with_http_info(self, policyinfo, **kwargs):  # noqa: E501
        """Update status of jobs. Only stop is supported for now.  # noqa: E501

        The endpoint is used to stop the replication jobs of a policy.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.jobs_replication_put_with_http_info(policyinfo, async=True)
        >>> result = thread.get()

        :param async bool
        :param UpdateJobs policyinfo: The policy ID and status. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['policyinfo']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method jobs_replication_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'policyinfo' is set
        if ('policyinfo' not in params or
                params['policyinfo'] is None):
            raise ValueError("Missing the required parameter `policyinfo` when calling `jobs_replication_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'policyinfo' in params:
            body_params = params['policyinfo']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/jobs/replication', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def jobs_scan_id_log_get(self, id, **kwargs):  # noqa: E501
        """Get job logs.  # noqa: E501

        This endpoint let user get scan job logs filtered by specific ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.jobs_scan_id_log_get(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: Relevant job ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.jobs_scan_id_log_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.jobs_scan_id_log_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def jobs_scan_id_log_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get job logs.  # noqa: E501

        This endpoint let user get scan job logs filtered by specific ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.jobs_scan_id_log_get_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: Relevant job ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method jobs_scan_id_log_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `jobs_scan_id_log_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/jobs/scan/{id}/log', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def labels_get(self, scope, **kwargs):  # noqa: E501
        """List labels according to the query strings.  # noqa: E501

        This endpoint let user list labels by name, scope and project_id   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.labels_get(scope, async=True)
        >>> result = thread.get()

        :param async bool
        :param str scope: The label scope. Valid values are g and p. g for global labels and p for project labels. (required)
        :param str name: The label name.
        :param int project_id: Relevant project ID, required when scope is p.
        :param int page: The page nubmer.
        :param int page_size: The size of per page.
        :return: list[Label]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.labels_get_with_http_info(scope, **kwargs)  # noqa: E501
        else:
            (data) = self.labels_get_with_http_info(scope, **kwargs)  # noqa: E501
            return data

    def labels_get_with_http_info(self, scope, **kwargs):  # noqa: E501
        """List labels according to the query strings.  # noqa: E501

        This endpoint let user list labels by name, scope and project_id   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.labels_get_with_http_info(scope, async=True)
        >>> result = thread.get()

        :param async bool
        :param str scope: The label scope. Valid values are g and p. g for global labels and p for project labels. (required)
        :param str name: The label name.
        :param int project_id: Relevant project ID, required when scope is p.
        :param int page: The page nubmer.
        :param int page_size: The size of per page.
        :return: list[Label]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['scope', 'name', 'project_id', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method labels_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'scope' is set
        if ('scope' not in params or
                params['scope'] is None):
            raise ValueError("Missing the required parameter `scope` when calling `labels_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'scope' in params:
            query_params.append(('scope', params['scope']))  # noqa: E501
        if 'project_id' in params:
            query_params.append(('project_id', params['project_id']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/labels', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Label]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def labels_id_delete(self, id, **kwargs):  # noqa: E501
        """Delete the label specified by ID.  # noqa: E501

        Delete the label specified by ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.labels_id_delete(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: Label ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.labels_id_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.labels_id_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def labels_id_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete the label specified by ID.  # noqa: E501

        Delete the label specified by ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.labels_id_delete_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: Label ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method labels_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `labels_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/labels/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def labels_id_get(self, id, **kwargs):  # noqa: E501
        """Get the label specified by ID.  # noqa: E501

        This endpoint let user get the label by specific ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.labels_id_get(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: Label ID (required)
        :return: Label
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.labels_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.labels_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def labels_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get the label specified by ID.  # noqa: E501

        This endpoint let user get the label by specific ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.labels_id_get_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: Label ID (required)
        :return: Label
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method labels_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `labels_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/labels/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Label',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def labels_id_put(self, id, label, **kwargs):  # noqa: E501
        """Update the label properties.  # noqa: E501

        This endpoint let user update label properties.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.labels_id_put(id, label, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: Label ID (required)
        :param Label label: The updated label json object. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.labels_id_put_with_http_info(id, label, **kwargs)  # noqa: E501
        else:
            (data) = self.labels_id_put_with_http_info(id, label, **kwargs)  # noqa: E501
            return data

    def labels_id_put_with_http_info(self, id, label, **kwargs):  # noqa: E501
        """Update the label properties.  # noqa: E501

        This endpoint let user update label properties.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.labels_id_put_with_http_info(id, label, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: Label ID (required)
        :param Label label: The updated label json object. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'label']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method labels_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `labels_id_put`")  # noqa: E501
        # verify the required parameter 'label' is set
        if ('label' not in params or
                params['label'] is None):
            raise ValueError("Missing the required parameter `label` when calling `labels_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'label' in params:
            body_params = params['label']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/labels/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def labels_id_resources_get(self, id, **kwargs):  # noqa: E501
        """Get the resources that the label is referenced by.  # noqa: E501

        This endpoint let user get the resources that the label is referenced by. Only the replication policies are returned for now.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.labels_id_resources_get(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: Label ID (required)
        :return: Resource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.labels_id_resources_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.labels_id_resources_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def labels_id_resources_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get the resources that the label is referenced by.  # noqa: E501

        This endpoint let user get the resources that the label is referenced by. Only the replication policies are returned for now.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.labels_id_resources_get_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: Label ID (required)
        :return: Resource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method labels_id_resources_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `labels_id_resources_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/labels/{id}/resources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Resource',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def labels_post(self, label, **kwargs):  # noqa: E501
        """Post creates a label  # noqa: E501

        This endpoint let user creates a label.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.labels_post(label, async=True)
        >>> result = thread.get()

        :param async bool
        :param Label label: The json object of label. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.labels_post_with_http_info(label, **kwargs)  # noqa: E501
        else:
            (data) = self.labels_post_with_http_info(label, **kwargs)  # noqa: E501
            return data

    def labels_post_with_http_info(self, label, **kwargs):  # noqa: E501
        """Post creates a label  # noqa: E501

        This endpoint let user creates a label.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.labels_post_with_http_info(label, async=True)
        >>> result = thread.get()

        :param async bool
        :param Label label: The json object of label. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['label']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method labels_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'label' is set
        if ('label' not in params or
                params['label'] is None):
            raise ValueError("Missing the required parameter `label` when calling `labels_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'label' in params:
            body_params = params['label']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/labels', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ldap_groups_search_get(self, **kwargs):  # noqa: E501
        """Search available ldap groups.  # noqa: E501

        This endpoint searches the available ldap groups based on related configuration parameters. support to search by groupname or groupdn.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.ldap_groups_search_get(async=True)
        >>> result = thread.get()

        :param async bool
        :param str groupname: Ldap group name
        :param str groupdn: The LDAP group DN
        :return: list[UserGroup]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.ldap_groups_search_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.ldap_groups_search_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def ldap_groups_search_get_with_http_info(self, **kwargs):  # noqa: E501
        """Search available ldap groups.  # noqa: E501

        This endpoint searches the available ldap groups based on related configuration parameters. support to search by groupname or groupdn.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.ldap_groups_search_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str groupname: Ldap group name
        :param str groupdn: The LDAP group DN
        :return: list[UserGroup]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['groupname', 'groupdn']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ldap_groups_search_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'groupname' in params:
            query_params.append(('groupname', params['groupname']))  # noqa: E501
        if 'groupdn' in params:
            query_params.append(('groupdn', params['groupdn']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ldap/groups/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[UserGroup]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ldap_ping_post(self, **kwargs):  # noqa: E501
        """Ping available ldap service.  # noqa: E501

        This endpoint ping the available ldap service for test related configuration parameters.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.ldap_ping_post(async=True)
        >>> result = thread.get()

        :param async bool
        :param LdapConf ldapconf: ldap configuration. support input ldap service configuration. If it's a empty request, will load current configuration from the system.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.ldap_ping_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.ldap_ping_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def ldap_ping_post_with_http_info(self, **kwargs):  # noqa: E501
        """Ping available ldap service.  # noqa: E501

        This endpoint ping the available ldap service for test related configuration parameters.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.ldap_ping_post_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param LdapConf ldapconf: ldap configuration. support input ldap service configuration. If it's a empty request, will load current configuration from the system.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ldapconf']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ldap_ping_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ldapconf' in params:
            body_params = params['ldapconf']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ldap/ping', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ldap_users_import_post(self, uid_list, **kwargs):  # noqa: E501
        """Import selected available ldap users.  # noqa: E501

        This endpoint adds the selected available ldap users to harbor based on related configuration parameters from the system. System will try to guess the user email address and realname, add to harbor user information.  If have errors when import user, will return the list of importing failed uid and the failed reason.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.ldap_users_import_post(uid_list, async=True)
        >>> result = thread.get()

        :param async bool
        :param LdapImportUsers uid_list: The uid listed for importing. This list will check users validity of ldap service based on configuration from the system. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.ldap_users_import_post_with_http_info(uid_list, **kwargs)  # noqa: E501
        else:
            (data) = self.ldap_users_import_post_with_http_info(uid_list, **kwargs)  # noqa: E501
            return data

    def ldap_users_import_post_with_http_info(self, uid_list, **kwargs):  # noqa: E501
        """Import selected available ldap users.  # noqa: E501

        This endpoint adds the selected available ldap users to harbor based on related configuration parameters from the system. System will try to guess the user email address and realname, add to harbor user information.  If have errors when import user, will return the list of importing failed uid and the failed reason.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.ldap_users_import_post_with_http_info(uid_list, async=True)
        >>> result = thread.get()

        :param async bool
        :param LdapImportUsers uid_list: The uid listed for importing. This list will check users validity of ldap service based on configuration from the system. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid_list']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ldap_users_import_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid_list' is set
        if ('uid_list' not in params or
                params['uid_list'] is None):
            raise ValueError("Missing the required parameter `uid_list` when calling `ldap_users_import_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'uid_list' in params:
            body_params = params['uid_list']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ldap/users/import', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ldap_users_search_get(self, **kwargs):  # noqa: E501
        """Search available ldap users.  # noqa: E501

        This endpoint searches the available ldap users based on related configuration parameters. Support searched by input ladp configuration, load configuration from the system and specific filter.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.ldap_users_search_get(async=True)
        >>> result = thread.get()

        :param async bool
        :param str username: Registered user ID
        :return: list[LdapUsers]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.ldap_users_search_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.ldap_users_search_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def ldap_users_search_get_with_http_info(self, **kwargs):  # noqa: E501
        """Search available ldap users.  # noqa: E501

        This endpoint searches the available ldap users based on related configuration parameters. Support searched by input ladp configuration, load configuration from the system and specific filter.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.ldap_users_search_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str username: Registered user ID
        :return: list[LdapUsers]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['username']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ldap_users_search_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'username' in params:
            query_params.append(('username', params['username']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ldap/users/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[LdapUsers]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def logs_get(self, **kwargs):  # noqa: E501
        """Get recent logs of the projects which the user is a member of  # noqa: E501

        This endpoint let user see the recent operation logs of the projects which he is member of    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.logs_get(async=True)
        >>> result = thread.get()

        :param async bool
        :param str username: Username of the operator.
        :param str repository: The name of repository
        :param str tag: The name of tag
        :param str operation: The operation
        :param str begin_timestamp: The begin timestamp
        :param str end_timestamp: The end timestamp
        :param int page: The page nubmer, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[AccessLog]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.logs_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.logs_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def logs_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get recent logs of the projects which the user is a member of  # noqa: E501

        This endpoint let user see the recent operation logs of the projects which he is member of    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.logs_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str username: Username of the operator.
        :param str repository: The name of repository
        :param str tag: The name of tag
        :param str operation: The operation
        :param str begin_timestamp: The begin timestamp
        :param str end_timestamp: The end timestamp
        :param int page: The page nubmer, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[AccessLog]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['username', 'repository', 'tag', 'operation', 'begin_timestamp', 'end_timestamp', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method logs_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'username' in params:
            query_params.append(('username', params['username']))  # noqa: E501
        if 'repository' in params:
            query_params.append(('repository', params['repository']))  # noqa: E501
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501
        if 'begin_timestamp' in params:
            query_params.append(('begin_timestamp', params['begin_timestamp']))  # noqa: E501
        if 'end_timestamp' in params:
            query_params.append(('end_timestamp', params['end_timestamp']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AccessLog]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def policies_replication_get(self, **kwargs):  # noqa: E501
        """List filters policies by name and project_id  # noqa: E501

        This endpoint let user list filters policies by name and project_id, if name and project_id are nil, list returns all policies   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.policies_replication_get(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: The replication's policy name.
        :param int project_id: Relevant project ID.
        :param int page: The page nubmer.
        :param int page_size: The size of per page.
        :return: list[RepPolicy]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.policies_replication_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.policies_replication_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def policies_replication_get_with_http_info(self, **kwargs):  # noqa: E501
        """List filters policies by name and project_id  # noqa: E501

        This endpoint let user list filters policies by name and project_id, if name and project_id are nil, list returns all policies   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.policies_replication_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: The replication's policy name.
        :param int project_id: Relevant project ID.
        :param int page: The page nubmer.
        :param int page_size: The size of per page.
        :return: list[RepPolicy]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'project_id', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method policies_replication_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'project_id' in params:
            query_params.append(('project_id', params['project_id']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/policies/replication', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RepPolicy]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def policies_replication_id_get(self, id, **kwargs):  # noqa: E501
        """Get replication policy.  # noqa: E501

        This endpoint let user search replication policy by specific ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.policies_replication_id_get(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: policy ID (required)
        :return: RepPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.policies_replication_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.policies_replication_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def policies_replication_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get replication policy.  # noqa: E501

        This endpoint let user search replication policy by specific ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.policies_replication_id_get_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: policy ID (required)
        :return: RepPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method policies_replication_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `policies_replication_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/policies/replication/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RepPolicy',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def policies_replication_id_put(self, id, policyupdate, **kwargs):  # noqa: E501
        """Put modifies name, description, target and enablement of policy.  # noqa: E501

        This endpoint let user update policy name, description, target and enablement.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.policies_replication_id_put(id, policyupdate, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: policy ID (required)
        :param RepPolicy policyupdate: Updated properties of the replication policy. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.policies_replication_id_put_with_http_info(id, policyupdate, **kwargs)  # noqa: E501
        else:
            (data) = self.policies_replication_id_put_with_http_info(id, policyupdate, **kwargs)  # noqa: E501
            return data

    def policies_replication_id_put_with_http_info(self, id, policyupdate, **kwargs):  # noqa: E501
        """Put modifies name, description, target and enablement of policy.  # noqa: E501

        This endpoint let user update policy name, description, target and enablement.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.policies_replication_id_put_with_http_info(id, policyupdate, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: policy ID (required)
        :param RepPolicy policyupdate: Updated properties of the replication policy. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'policyupdate']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method policies_replication_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `policies_replication_id_put`")  # noqa: E501
        # verify the required parameter 'policyupdate' is set
        if ('policyupdate' not in params or
                params['policyupdate'] is None):
            raise ValueError("Missing the required parameter `policyupdate` when calling `policies_replication_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'policyupdate' in params:
            body_params = params['policyupdate']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/policies/replication/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def policies_replication_post(self, policyinfo, **kwargs):  # noqa: E501
        """Post creates a policy  # noqa: E501

        This endpoint let user creates a policy, and if it is enabled, the replication will be triggered right now.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.policies_replication_post(policyinfo, async=True)
        >>> result = thread.get()

        :param async bool
        :param RepPolicy policyinfo: Create new policy. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.policies_replication_post_with_http_info(policyinfo, **kwargs)  # noqa: E501
        else:
            (data) = self.policies_replication_post_with_http_info(policyinfo, **kwargs)  # noqa: E501
            return data

    def policies_replication_post_with_http_info(self, policyinfo, **kwargs):  # noqa: E501
        """Post creates a policy  # noqa: E501

        This endpoint let user creates a policy, and if it is enabled, the replication will be triggered right now.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.policies_replication_post_with_http_info(policyinfo, async=True)
        >>> result = thread.get()

        :param async bool
        :param RepPolicy policyinfo: Create new policy. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['policyinfo']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method policies_replication_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'policyinfo' is set
        if ('policyinfo' not in params or
                params['policyinfo'] is None):
            raise ValueError("Missing the required parameter `policyinfo` when calling `policies_replication_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'policyinfo' in params:
            body_params = params['policyinfo']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/policies/replication', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_get(self, **kwargs):  # noqa: E501
        """List projects  # noqa: E501

        This endpoint returns all projects created by Harbor, and can be filtered by project name.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_get(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: The name of project.
        :param bool public: The project is public or private.
        :param str owner: The name of project owner.
        :param int page: The page nubmer, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[Project]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.projects_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def projects_get_with_http_info(self, **kwargs):  # noqa: E501
        """List projects  # noqa: E501

        This endpoint returns all projects created by Harbor, and can be filtered by project name.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: The name of project.
        :param bool public: The project is public or private.
        :param str owner: The name of project owner.
        :param int page: The page nubmer, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[Project]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'public', 'owner', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'public' in params:
            query_params.append(('public', params['public']))  # noqa: E501
        if 'owner' in params:
            query_params.append(('owner', params['owner']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Project]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_head(self, project_name, **kwargs):  # noqa: E501
        """Check if the project name user provided already exists.  # noqa: E501

        This endpoint is used to check if the project name user provided already exist.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_head(project_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_name: Project name for checking exists. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_head_with_http_info(project_name, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_head_with_http_info(project_name, **kwargs)  # noqa: E501
            return data

    def projects_head_with_http_info(self, project_name, **kwargs):  # noqa: E501
        """Check if the project name user provided already exists.  # noqa: E501

        This endpoint is used to check if the project name user provided already exist.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_head_with_http_info(project_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str project_name: Project name for checking exists. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_head" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_name' is set
        if ('project_name' not in params or
                params['project_name'] is None):
            raise ValueError("Missing the required parameter `project_name` when calling `projects_head`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_name' in params:
            query_params.append(('project_name', params['project_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects', 'HEAD',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_post(self, project, **kwargs):  # noqa: E501
        """Create a new project.  # noqa: E501

        This endpoint is for user to create a new project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_post(project, async=True)
        >>> result = thread.get()

        :param async bool
        :param ProjectReq project: New created project. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_post_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_post_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def projects_post_with_http_info(self, project, **kwargs):  # noqa: E501
        """Create a new project.  # noqa: E501

        This endpoint is for user to create a new project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_post_with_http_info(project, async=True)
        >>> result = thread.get()

        :param async bool
        :param ProjectReq project: New created project. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project' in params:
            body_params = params['project']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_delete(self, project_id, **kwargs):  # noqa: E501
        """Delete project by projectID  # noqa: E501

        This endpoint is aimed to delete project by project ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_delete(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: Project ID of project which will be deleted. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_delete_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_delete_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_delete_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Delete project by projectID  # noqa: E501

        This endpoint is aimed to delete project by project ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_delete_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: Project ID of project which will be deleted. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_get(self, project_id, **kwargs):  # noqa: E501
        """Return specific project detail infomation  # noqa: E501

        This endpoint returns specific project information by project ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_get(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: Project ID for filtering results. (required)
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_get_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_get_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Return specific project detail infomation  # noqa: E501

        This endpoint returns specific project information by project ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_get_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: Project ID for filtering results. (required)
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Project',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_logs_get(self, project_id, **kwargs):  # noqa: E501
        """Get access logs accompany with a relevant project.  # noqa: E501

        This endpoint let user search access logs filtered by operations and date time ranges.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_logs_get(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: Relevant project ID (required)
        :param str username: Username of the operator.
        :param str repository: The name of repository
        :param str tag: The name of tag
        :param str operation: The operation
        :param str begin_timestamp: The begin timestamp
        :param str end_timestamp: The end timestamp
        :param int page: The page nubmer, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[AccessLog]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_logs_get_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_logs_get_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_logs_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get access logs accompany with a relevant project.  # noqa: E501

        This endpoint let user search access logs filtered by operations and date time ranges.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_logs_get_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: Relevant project ID (required)
        :param str username: Username of the operator.
        :param str repository: The name of repository
        :param str tag: The name of tag
        :param str operation: The operation
        :param str begin_timestamp: The begin timestamp
        :param str end_timestamp: The end timestamp
        :param int page: The page nubmer, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[AccessLog]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'username', 'repository', 'tag', 'operation', 'begin_timestamp', 'end_timestamp', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_logs_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_logs_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []
        if 'username' in params:
            query_params.append(('username', params['username']))  # noqa: E501
        if 'repository' in params:
            query_params.append(('repository', params['repository']))  # noqa: E501
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501
        if 'begin_timestamp' in params:
            query_params.append(('begin_timestamp', params['begin_timestamp']))  # noqa: E501
        if 'end_timestamp' in params:
            query_params.append(('end_timestamp', params['end_timestamp']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AccessLog]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_members_get(self, project_id, **kwargs):  # noqa: E501
        """Get all project member information  # noqa: E501

        Get all project member information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_members_get(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: Relevant project ID. (required)
        :param str entityname: The entity name to search.
        :return: list[ProjectMemberEntity]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_members_get_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_members_get_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_members_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get all project member information  # noqa: E501

        Get all project member information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_members_get_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: Relevant project ID. (required)
        :param str entityname: The entity name to search.
        :return: list[ProjectMemberEntity]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'entityname']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_members_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_members_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []
        if 'entityname' in params:
            query_params.append(('entityname', params['entityname']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/members', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ProjectMemberEntity]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_members_mid_delete(self, project_id, mid, **kwargs):  # noqa: E501
        """Delete project member  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_members_mid_delete(project_id, mid, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: Relevant project ID. (required)
        :param int mid: Member ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_members_mid_delete_with_http_info(project_id, mid, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_members_mid_delete_with_http_info(project_id, mid, **kwargs)  # noqa: E501
            return data

    def projects_project_id_members_mid_delete_with_http_info(self, project_id, mid, **kwargs):  # noqa: E501
        """Delete project member  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_members_mid_delete_with_http_info(project_id, mid, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: Relevant project ID. (required)
        :param int mid: Member ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'mid']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_members_mid_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_members_mid_delete`")  # noqa: E501
        # verify the required parameter 'mid' is set
        if ('mid' not in params or
                params['mid'] is None):
            raise ValueError("Missing the required parameter `mid` when calling `projects_project_id_members_mid_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501
        if 'mid' in params:
            path_params['mid'] = params['mid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/members/{mid}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_members_mid_get(self, project_id, mid, **kwargs):  # noqa: E501
        """Get the project member information  # noqa: E501

        Get the project member information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_members_mid_get(project_id, mid, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: Relevant project ID. (required)
        :param int mid: The member ID (required)
        :return: ProjectMemberEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_members_mid_get_with_http_info(project_id, mid, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_members_mid_get_with_http_info(project_id, mid, **kwargs)  # noqa: E501
            return data

    def projects_project_id_members_mid_get_with_http_info(self, project_id, mid, **kwargs):  # noqa: E501
        """Get the project member information  # noqa: E501

        Get the project member information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_members_mid_get_with_http_info(project_id, mid, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: Relevant project ID. (required)
        :param int mid: The member ID (required)
        :return: ProjectMemberEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'mid']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_members_mid_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_members_mid_get`")  # noqa: E501
        # verify the required parameter 'mid' is set
        if ('mid' not in params or
                params['mid'] is None):
            raise ValueError("Missing the required parameter `mid` when calling `projects_project_id_members_mid_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501
        if 'mid' in params:
            path_params['mid'] = params['mid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/members/{mid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectMemberEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_members_mid_put(self, project_id, mid, **kwargs):  # noqa: E501
        """Update project member  # noqa: E501

        Update project member relationship  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_members_mid_put(project_id, mid, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: Relevant project ID. (required)
        :param int mid: Member ID. (required)
        :param RoleRequest role:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_members_mid_put_with_http_info(project_id, mid, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_members_mid_put_with_http_info(project_id, mid, **kwargs)  # noqa: E501
            return data

    def projects_project_id_members_mid_put_with_http_info(self, project_id, mid, **kwargs):  # noqa: E501
        """Update project member  # noqa: E501

        Update project member relationship  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_members_mid_put_with_http_info(project_id, mid, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: Relevant project ID. (required)
        :param int mid: Member ID. (required)
        :param RoleRequest role:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'mid', 'role']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_members_mid_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_members_mid_put`")  # noqa: E501
        # verify the required parameter 'mid' is set
        if ('mid' not in params or
                params['mid'] is None):
            raise ValueError("Missing the required parameter `mid` when calling `projects_project_id_members_mid_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501
        if 'mid' in params:
            path_params['mid'] = params['mid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'role' in params:
            body_params = params['role']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/members/{mid}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_members_post(self, project_id, **kwargs):  # noqa: E501
        """Create project member  # noqa: E501

        Create project member relationship, the member can be one of the user_member and group_member,  The user_member need to specify user_id or username. If the user already exist in harbor DB, specify the user_id,  If does not exist in harbor DB, it will SearchAndOnBoard the user. The group_member need to specify id or ldap_group_dn. If the group already exist in harbor DB. specify the user group's id,  If does not exist, it will SearchAndOnBoard the group.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_members_post(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: Relevant project ID. (required)
        :param ProjectMember project_member:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_members_post_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_members_post_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_members_post_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Create project member  # noqa: E501

        Create project member relationship, the member can be one of the user_member and group_member,  The user_member need to specify user_id or username. If the user already exist in harbor DB, specify the user_id,  If does not exist in harbor DB, it will SearchAndOnBoard the user. The group_member need to specify id or ldap_group_dn. If the group already exist in harbor DB. specify the user group's id,  If does not exist, it will SearchAndOnBoard the group.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_members_post_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: Relevant project ID. (required)
        :param ProjectMember project_member:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'project_member']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_members_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_members_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_member' in params:
            body_params = params['project_member']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/members', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_metadatas_get(self, project_id, **kwargs):  # noqa: E501
        """Get project metadata.  # noqa: E501

        This endpoint returns metadata of the project specified by project ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_metadatas_get(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: The ID of project. (required)
        :return: ProjectMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_metadatas_get_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_metadatas_get_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_metadatas_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get project metadata.  # noqa: E501

        This endpoint returns metadata of the project specified by project ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_metadatas_get_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: The ID of project. (required)
        :return: ProjectMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_metadatas_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_metadatas_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/metadatas', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectMetadata',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_metadatas_meta_name_delete(self, project_id, meta_name, **kwargs):  # noqa: E501
        """Delete metadata of a project  # noqa: E501

        This endpoint is aimed to delete metadata of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_metadatas_meta_name_delete(project_id, meta_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: The ID of project. (required)
        :param str meta_name: The name of metadat. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_metadatas_meta_name_delete_with_http_info(project_id, meta_name, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_metadatas_meta_name_delete_with_http_info(project_id, meta_name, **kwargs)  # noqa: E501
            return data

    def projects_project_id_metadatas_meta_name_delete_with_http_info(self, project_id, meta_name, **kwargs):  # noqa: E501
        """Delete metadata of a project  # noqa: E501

        This endpoint is aimed to delete metadata of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_metadatas_meta_name_delete_with_http_info(project_id, meta_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: The ID of project. (required)
        :param str meta_name: The name of metadat. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'meta_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_metadatas_meta_name_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_metadatas_meta_name_delete`")  # noqa: E501
        # verify the required parameter 'meta_name' is set
        if ('meta_name' not in params or
                params['meta_name'] is None):
            raise ValueError("Missing the required parameter `meta_name` when calling `projects_project_id_metadatas_meta_name_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501
        if 'meta_name' in params:
            path_params['meta_name'] = params['meta_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/metadatas/{meta_name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_metadatas_meta_name_get(self, project_id, meta_name, **kwargs):  # noqa: E501
        """Get project metadata  # noqa: E501

        This endpoint returns specified metadata of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_metadatas_meta_name_get(project_id, meta_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: Project ID for filtering results. (required)
        :param str meta_name: The name of metadat. (required)
        :return: ProjectMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_metadatas_meta_name_get_with_http_info(project_id, meta_name, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_metadatas_meta_name_get_with_http_info(project_id, meta_name, **kwargs)  # noqa: E501
            return data

    def projects_project_id_metadatas_meta_name_get_with_http_info(self, project_id, meta_name, **kwargs):  # noqa: E501
        """Get project metadata  # noqa: E501

        This endpoint returns specified metadata of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_metadatas_meta_name_get_with_http_info(project_id, meta_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: Project ID for filtering results. (required)
        :param str meta_name: The name of metadat. (required)
        :return: ProjectMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'meta_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_metadatas_meta_name_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_metadatas_meta_name_get`")  # noqa: E501
        # verify the required parameter 'meta_name' is set
        if ('meta_name' not in params or
                params['meta_name'] is None):
            raise ValueError("Missing the required parameter `meta_name` when calling `projects_project_id_metadatas_meta_name_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501
        if 'meta_name' in params:
            path_params['meta_name'] = params['meta_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/metadatas/{meta_name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectMetadata',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_metadatas_meta_name_put(self, project_id, meta_name, **kwargs):  # noqa: E501
        """Update metadata of a project.  # noqa: E501

        This endpoint is aimed to update the metadata of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_metadatas_meta_name_put(project_id, meta_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: The ID of project. (required)
        :param str meta_name: The name of metadat. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_metadatas_meta_name_put_with_http_info(project_id, meta_name, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_metadatas_meta_name_put_with_http_info(project_id, meta_name, **kwargs)  # noqa: E501
            return data

    def projects_project_id_metadatas_meta_name_put_with_http_info(self, project_id, meta_name, **kwargs):  # noqa: E501
        """Update metadata of a project.  # noqa: E501

        This endpoint is aimed to update the metadata of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_metadatas_meta_name_put_with_http_info(project_id, meta_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: The ID of project. (required)
        :param str meta_name: The name of metadat. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'meta_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_metadatas_meta_name_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_metadatas_meta_name_put`")  # noqa: E501
        # verify the required parameter 'meta_name' is set
        if ('meta_name' not in params or
                params['meta_name'] is None):
            raise ValueError("Missing the required parameter `meta_name` when calling `projects_project_id_metadatas_meta_name_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501
        if 'meta_name' in params:
            path_params['meta_name'] = params['meta_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/metadatas/{meta_name}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_metadatas_post(self, project_id, metadata, **kwargs):  # noqa: E501
        """Add metadata for the project.  # noqa: E501

        This endpoint is aimed to add metadata of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_metadatas_post(project_id, metadata, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: Selected project ID. (required)
        :param ProjectMetadata metadata: The metadata of project. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_metadatas_post_with_http_info(project_id, metadata, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_metadatas_post_with_http_info(project_id, metadata, **kwargs)  # noqa: E501
            return data

    def projects_project_id_metadatas_post_with_http_info(self, project_id, metadata, **kwargs):  # noqa: E501
        """Add metadata for the project.  # noqa: E501

        This endpoint is aimed to add metadata of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_metadatas_post_with_http_info(project_id, metadata, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: Selected project ID. (required)
        :param ProjectMetadata metadata: The metadata of project. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'metadata']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_metadatas_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_metadatas_post`")  # noqa: E501
        # verify the required parameter 'metadata' is set
        if ('metadata' not in params or
                params['metadata'] is None):
            raise ValueError("Missing the required parameter `metadata` when calling `projects_project_id_metadatas_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'metadata' in params:
            body_params = params['metadata']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/metadatas', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_put(self, project_id, project, **kwargs):  # noqa: E501
        """Update properties for a selected project.  # noqa: E501

        This endpoint is aimed to update the properties of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_put(project_id, project, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: Selected project ID. (required)
        :param ProjectReq project: Updates of project. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.projects_project_id_put_with_http_info(project_id, project, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_put_with_http_info(project_id, project, **kwargs)  # noqa: E501
            return data

    def projects_project_id_put_with_http_info(self, project_id, project, **kwargs):  # noqa: E501
        """Update properties for a selected project.  # noqa: E501

        This endpoint is aimed to update the properties of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.projects_project_id_put_with_http_info(project_id, project, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: Selected project ID. (required)
        :param ProjectReq project: Updates of project. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'project']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_put`")  # noqa: E501
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_project_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project' in params:
            body_params = params['project']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replications_post(self, policy_id, **kwargs):  # noqa: E501
        """Trigger the replication according to the specified policy.  # noqa: E501

        This endpoint is used to trigger a replication.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.replications_post(policy_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param Replication policy_id: The ID of replication policy. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.replications_post_with_http_info(policy_id, **kwargs)  # noqa: E501
        else:
            (data) = self.replications_post_with_http_info(policy_id, **kwargs)  # noqa: E501
            return data

    def replications_post_with_http_info(self, policy_id, **kwargs):  # noqa: E501
        """Trigger the replication according to the specified policy.  # noqa: E501

        This endpoint is used to trigger a replication.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.replications_post_with_http_info(policy_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param Replication policy_id: The ID of replication policy. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['policy_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replications_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'policy_id' is set
        if ('policy_id' not in params or
                params['policy_id'] is None):
            raise ValueError("Missing the required parameter `policy_id` when calling `replications_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'policy_id' in params:
            body_params = params['policy_id']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/replications', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_get(self, project_id, **kwargs):  # noqa: E501
        """Get repositories accompany with relevant project and repo name.  # noqa: E501

        This endpoint let user search repositories accompanying with relevant project ID and repo name.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_get(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: Relevant project ID. (required)
        :param str q: Repo name for filtering results.
        :param int label_id: The ID of label used to filter the result.
        :param int page: The page nubmer, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[Repository]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_get_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_get_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def repositories_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get repositories accompany with relevant project and repo name.  # noqa: E501

        This endpoint let user search repositories accompanying with relevant project ID and repo name.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_get_with_http_info(project_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int project_id: Relevant project ID. (required)
        :param str q: Repo name for filtering results.
        :param int label_id: The ID of label used to filter the result.
        :param int page: The page nubmer, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[Repository]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'q', 'label_id', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `repositories_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in params:
            query_params.append(('project_id', params['project_id']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'label_id' in params:
            query_params.append(('label_id', params['label_id']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Repository]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_delete(self, repo_name, **kwargs):  # noqa: E501
        """Delete a repository.  # noqa: E501

        This endpoint let user delete a repository with name.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_delete(repo_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: The name of repository which will be deleted. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_repo_name_delete_with_http_info(repo_name, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_delete_with_http_info(repo_name, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_delete_with_http_info(self, repo_name, **kwargs):  # noqa: E501
        """Delete a repository.  # noqa: E501

        This endpoint let user delete a repository with name.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_delete_with_http_info(repo_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: The name of repository which will be deleted. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_labels_get(self, repo_name, **kwargs):  # noqa: E501
        """Get labels of a repository.  # noqa: E501

        Get labels of a repository specified by the repo_name.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_labels_get(repo_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: The name of repository. (required)
        :return: list[Label]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_repo_name_labels_get_with_http_info(repo_name, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_labels_get_with_http_info(repo_name, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_labels_get_with_http_info(self, repo_name, **kwargs):  # noqa: E501
        """Get labels of a repository.  # noqa: E501

        Get labels of a repository specified by the repo_name.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_labels_get_with_http_info(repo_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: The name of repository. (required)
        :return: list[Label]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_labels_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_labels_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/labels', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Label]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_labels_label_id_delete(self, repo_name, label_id, **kwargs):  # noqa: E501
        """Delete label from the repository.  # noqa: E501

        Delete the label from the repository specified by the repo_name.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_labels_label_id_delete(repo_name, label_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: The name of repository. (required)
        :param int label_id: The ID of label. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_repo_name_labels_label_id_delete_with_http_info(repo_name, label_id, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_labels_label_id_delete_with_http_info(repo_name, label_id, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_labels_label_id_delete_with_http_info(self, repo_name, label_id, **kwargs):  # noqa: E501
        """Delete label from the repository.  # noqa: E501

        Delete the label from the repository specified by the repo_name.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_labels_label_id_delete_with_http_info(repo_name, label_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: The name of repository. (required)
        :param int label_id: The ID of label. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name', 'label_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_labels_label_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_labels_label_id_delete`")  # noqa: E501
        # verify the required parameter 'label_id' is set
        if ('label_id' not in params or
                params['label_id'] is None):
            raise ValueError("Missing the required parameter `label_id` when calling `repositories_repo_name_labels_label_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501
        if 'label_id' in params:
            path_params['label_id'] = params['label_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/labels/{label_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_labels_post(self, repo_name, label, **kwargs):  # noqa: E501
        """Add a label to the repository.  # noqa: E501

        Add a label to the repository.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_labels_post(repo_name, label, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: The name of repository. (required)
        :param Label label: Only the ID property is required. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_repo_name_labels_post_with_http_info(repo_name, label, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_labels_post_with_http_info(repo_name, label, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_labels_post_with_http_info(self, repo_name, label, **kwargs):  # noqa: E501
        """Add a label to the repository.  # noqa: E501

        Add a label to the repository.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_labels_post_with_http_info(repo_name, label, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: The name of repository. (required)
        :param Label label: Only the ID property is required. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name', 'label']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_labels_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_labels_post`")  # noqa: E501
        # verify the required parameter 'label' is set
        if ('label' not in params or
                params['label'] is None):
            raise ValueError("Missing the required parameter `label` when calling `repositories_repo_name_labels_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'label' in params:
            body_params = params['label']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/labels', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_put(self, repo_name, description, **kwargs):  # noqa: E501
        """Update description of the repository.  # noqa: E501

        This endpoint is used to update description of the repository.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_put(repo_name, description, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: The name of repository which will be deleted. (required)
        :param RepositoryDescription description: The description of the repository. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_repo_name_put_with_http_info(repo_name, description, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_put_with_http_info(repo_name, description, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_put_with_http_info(self, repo_name, description, **kwargs):  # noqa: E501
        """Update description of the repository.  # noqa: E501

        This endpoint is used to update description of the repository.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_put_with_http_info(repo_name, description, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: The name of repository which will be deleted. (required)
        :param RepositoryDescription description: The description of the repository. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name', 'description']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_put`")  # noqa: E501
        # verify the required parameter 'description' is set
        if ('description' not in params or
                params['description'] is None):
            raise ValueError("Missing the required parameter `description` when calling `repositories_repo_name_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'description' in params:
            body_params = params['description']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_signatures_get(self, repo_name, **kwargs):  # noqa: E501
        """Get signature information of a repository  # noqa: E501

        This endpoint aims to retrieve signature information of a repository, the data is from the nested notary instance of Harbor. If the repository does not have any signature information in notary, this API will return an empty list with response code 200, instead of 404   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_signatures_get(repo_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: repository name. (required)
        :return: list[RepoSignature]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_repo_name_signatures_get_with_http_info(repo_name, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_signatures_get_with_http_info(repo_name, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_signatures_get_with_http_info(self, repo_name, **kwargs):  # noqa: E501
        """Get signature information of a repository  # noqa: E501

        This endpoint aims to retrieve signature information of a repository, the data is from the nested notary instance of Harbor. If the repository does not have any signature information in notary, this API will return an empty list with response code 200, instead of 404   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_signatures_get_with_http_info(repo_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: repository name. (required)
        :return: list[RepoSignature]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_signatures_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_signatures_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/signatures', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RepoSignature]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_tags_get(self, repo_name, **kwargs):  # noqa: E501
        """Get tags of a relevant repository.  # noqa: E501

        This endpoint aims to retrieve tags from a relevant repository. If deployed with Notary, the signature property of response represents whether the image is singed or not. If the property is null, the image is unsigned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_tags_get(repo_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: Relevant repository name. (required)
        :param str label_ids: A list of comma separated label IDs.
        :return: list[DetailedTag]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_repo_name_tags_get_with_http_info(repo_name, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_tags_get_with_http_info(repo_name, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_tags_get_with_http_info(self, repo_name, **kwargs):  # noqa: E501
        """Get tags of a relevant repository.  # noqa: E501

        This endpoint aims to retrieve tags from a relevant repository. If deployed with Notary, the signature property of response represents whether the image is singed or not. If the property is null, the image is unsigned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_tags_get_with_http_info(repo_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: Relevant repository name. (required)
        :param str label_ids: A list of comma separated label IDs.
        :return: list[DetailedTag]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name', 'label_ids']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_tags_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_tags_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501

        query_params = []
        if 'label_ids' in params:
            query_params.append(('label_ids', params['label_ids']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/tags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DetailedTag]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_tags_tag_delete(self, repo_name, tag, **kwargs):  # noqa: E501
        """Delete a tag in a repository.  # noqa: E501

        This endpoint let user delete tags with repo name and tag.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_tags_tag_delete(repo_name, tag, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: The name of repository which will be deleted. (required)
        :param str tag: Tag of a repository. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_repo_name_tags_tag_delete_with_http_info(repo_name, tag, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_tags_tag_delete_with_http_info(repo_name, tag, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_tags_tag_delete_with_http_info(self, repo_name, tag, **kwargs):  # noqa: E501
        """Delete a tag in a repository.  # noqa: E501

        This endpoint let user delete tags with repo name and tag.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_tags_tag_delete_with_http_info(repo_name, tag, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: The name of repository which will be deleted. (required)
        :param str tag: Tag of a repository. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name', 'tag']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_tags_tag_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_tags_tag_delete`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if ('tag' not in params or
                params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `repositories_repo_name_tags_tag_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501
        if 'tag' in params:
            path_params['tag'] = params['tag']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/tags/{tag}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_tags_tag_get(self, repo_name, tag, **kwargs):  # noqa: E501
        """Get the tag of the repository.  # noqa: E501

        This endpoint aims to retrieve the tag of the repository. If deployed with Notary, the signature property of response represents whether the image is singed or not. If the property is null, the image is unsigned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_tags_tag_get(repo_name, tag, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: Relevant repository name. (required)
        :param str tag: Tag of the repository. (required)
        :return: DetailedTag
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_repo_name_tags_tag_get_with_http_info(repo_name, tag, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_tags_tag_get_with_http_info(repo_name, tag, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_tags_tag_get_with_http_info(self, repo_name, tag, **kwargs):  # noqa: E501
        """Get the tag of the repository.  # noqa: E501

        This endpoint aims to retrieve the tag of the repository. If deployed with Notary, the signature property of response represents whether the image is singed or not. If the property is null, the image is unsigned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_tags_tag_get_with_http_info(repo_name, tag, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: Relevant repository name. (required)
        :param str tag: Tag of the repository. (required)
        :return: DetailedTag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name', 'tag']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_tags_tag_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_tags_tag_get`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if ('tag' not in params or
                params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `repositories_repo_name_tags_tag_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501
        if 'tag' in params:
            path_params['tag'] = params['tag']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/tags/{tag}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DetailedTag',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_tags_tag_labels_get(self, repo_name, tag, **kwargs):  # noqa: E501
        """Get labels of an image.  # noqa: E501

        Get labels of an image specified by the repo_name and tag.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_tags_tag_labels_get(repo_name, tag, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: The name of repository. (required)
        :param str tag: The tag of the image. (required)
        :return: list[Label]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_repo_name_tags_tag_labels_get_with_http_info(repo_name, tag, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_tags_tag_labels_get_with_http_info(repo_name, tag, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_tags_tag_labels_get_with_http_info(self, repo_name, tag, **kwargs):  # noqa: E501
        """Get labels of an image.  # noqa: E501

        Get labels of an image specified by the repo_name and tag.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_tags_tag_labels_get_with_http_info(repo_name, tag, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: The name of repository. (required)
        :param str tag: The tag of the image. (required)
        :return: list[Label]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name', 'tag']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_tags_tag_labels_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_tags_tag_labels_get`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if ('tag' not in params or
                params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `repositories_repo_name_tags_tag_labels_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501
        if 'tag' in params:
            path_params['tag'] = params['tag']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/tags/{tag}/labels', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Label]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_tags_tag_labels_label_id_delete(self, repo_name, tag, label_id, **kwargs):  # noqa: E501
        """Delete label from the image.  # noqa: E501

        Delete the label from the image specified by the repo_name and tag.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_tags_tag_labels_label_id_delete(repo_name, tag, label_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: The name of repository. (required)
        :param str tag: The tag of the image. (required)
        :param int label_id: The ID of label. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_repo_name_tags_tag_labels_label_id_delete_with_http_info(repo_name, tag, label_id, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_tags_tag_labels_label_id_delete_with_http_info(repo_name, tag, label_id, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_tags_tag_labels_label_id_delete_with_http_info(self, repo_name, tag, label_id, **kwargs):  # noqa: E501
        """Delete label from the image.  # noqa: E501

        Delete the label from the image specified by the repo_name and tag.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_tags_tag_labels_label_id_delete_with_http_info(repo_name, tag, label_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: The name of repository. (required)
        :param str tag: The tag of the image. (required)
        :param int label_id: The ID of label. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name', 'tag', 'label_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_tags_tag_labels_label_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_tags_tag_labels_label_id_delete`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if ('tag' not in params or
                params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `repositories_repo_name_tags_tag_labels_label_id_delete`")  # noqa: E501
        # verify the required parameter 'label_id' is set
        if ('label_id' not in params or
                params['label_id'] is None):
            raise ValueError("Missing the required parameter `label_id` when calling `repositories_repo_name_tags_tag_labels_label_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501
        if 'tag' in params:
            path_params['tag'] = params['tag']  # noqa: E501
        if 'label_id' in params:
            path_params['label_id'] = params['label_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/tags/{tag}/labels/{label_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_tags_tag_labels_post(self, repo_name, tag, label, **kwargs):  # noqa: E501
        """Add a label to image.  # noqa: E501

        Add a label to the image.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_tags_tag_labels_post(repo_name, tag, label, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: The name of repository. (required)
        :param str tag: The tag of the image. (required)
        :param Label label: Only the ID property is required. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_repo_name_tags_tag_labels_post_with_http_info(repo_name, tag, label, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_tags_tag_labels_post_with_http_info(repo_name, tag, label, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_tags_tag_labels_post_with_http_info(self, repo_name, tag, label, **kwargs):  # noqa: E501
        """Add a label to image.  # noqa: E501

        Add a label to the image.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_tags_tag_labels_post_with_http_info(repo_name, tag, label, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: The name of repository. (required)
        :param str tag: The tag of the image. (required)
        :param Label label: Only the ID property is required. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name', 'tag', 'label']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_tags_tag_labels_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_tags_tag_labels_post`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if ('tag' not in params or
                params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `repositories_repo_name_tags_tag_labels_post`")  # noqa: E501
        # verify the required parameter 'label' is set
        if ('label' not in params or
                params['label'] is None):
            raise ValueError("Missing the required parameter `label` when calling `repositories_repo_name_tags_tag_labels_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501
        if 'tag' in params:
            path_params['tag'] = params['tag']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'label' in params:
            body_params = params['label']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/tags/{tag}/labels', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_tags_tag_manifest_get(self, repo_name, tag, **kwargs):  # noqa: E501
        """Get manifests of a relevant repository.  # noqa: E501

        This endpoint aims to retreive manifests from a relevant repository.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_tags_tag_manifest_get(repo_name, tag, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: Repository name (required)
        :param str tag: Tag name (required)
        :param str version: The version of manifest, valid value are \"v1\" and \"v2\", default is \"v2\"
        :return: Manifest
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_repo_name_tags_tag_manifest_get_with_http_info(repo_name, tag, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_tags_tag_manifest_get_with_http_info(repo_name, tag, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_tags_tag_manifest_get_with_http_info(self, repo_name, tag, **kwargs):  # noqa: E501
        """Get manifests of a relevant repository.  # noqa: E501

        This endpoint aims to retreive manifests from a relevant repository.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_tags_tag_manifest_get_with_http_info(repo_name, tag, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: Repository name (required)
        :param str tag: Tag name (required)
        :param str version: The version of manifest, valid value are \"v1\" and \"v2\", default is \"v2\"
        :return: Manifest
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name', 'tag', 'version']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_tags_tag_manifest_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_tags_tag_manifest_get`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if ('tag' not in params or
                params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `repositories_repo_name_tags_tag_manifest_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501
        if 'tag' in params:
            path_params['tag'] = params['tag']  # noqa: E501

        query_params = []
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/tags/{tag}/manifest', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Manifest',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_tags_tag_scan_post(self, repo_name, tag, **kwargs):  # noqa: E501
        """Scan the image.  # noqa: E501

        Trigger jobservice to call Clair API to scan the image identified by the repo_name and tag.  Only project admins have permission to scan images under the project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_tags_tag_scan_post(repo_name, tag, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: Repository name (required)
        :param str tag: Tag name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_repo_name_tags_tag_scan_post_with_http_info(repo_name, tag, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_tags_tag_scan_post_with_http_info(repo_name, tag, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_tags_tag_scan_post_with_http_info(self, repo_name, tag, **kwargs):  # noqa: E501
        """Scan the image.  # noqa: E501

        Trigger jobservice to call Clair API to scan the image identified by the repo_name and tag.  Only project admins have permission to scan images under the project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_tags_tag_scan_post_with_http_info(repo_name, tag, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: Repository name (required)
        :param str tag: Tag name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name', 'tag']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_tags_tag_scan_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_tags_tag_scan_post`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if ('tag' not in params or
                params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `repositories_repo_name_tags_tag_scan_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501
        if 'tag' in params:
            path_params['tag'] = params['tag']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/tags/{tag}/scan', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_tags_tag_vulnerability_details_get(self, repo_name, tag, **kwargs):  # noqa: E501
        """Get vulnerability details of the image.  # noqa: E501

        Call Clair API to get the vulnerability based on the previous successful scan.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_tags_tag_vulnerability_details_get(repo_name, tag, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: Repository name (required)
        :param str tag: Tag name (required)
        :return: list[VulnerabilityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_repo_name_tags_tag_vulnerability_details_get_with_http_info(repo_name, tag, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_tags_tag_vulnerability_details_get_with_http_info(repo_name, tag, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_tags_tag_vulnerability_details_get_with_http_info(self, repo_name, tag, **kwargs):  # noqa: E501
        """Get vulnerability details of the image.  # noqa: E501

        Call Clair API to get the vulnerability based on the previous successful scan.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_repo_name_tags_tag_vulnerability_details_get_with_http_info(repo_name, tag, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repo_name: Repository name (required)
        :param str tag: Tag name (required)
        :return: list[VulnerabilityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name', 'tag']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_tags_tag_vulnerability_details_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_tags_tag_vulnerability_details_get`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if ('tag' not in params or
                params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `repositories_repo_name_tags_tag_vulnerability_details_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501
        if 'tag' in params:
            path_params['tag'] = params['tag']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/tags/{tag}/vulnerability/details', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VulnerabilityItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_top_get(self, **kwargs):  # noqa: E501
        """Get public repositories which are accessed most.  # noqa: E501

        This endpoint aims to let users see the most popular public repositories   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_top_get(async=True)
        >>> result = thread.get()

        :param async bool
        :param int count: The number of the requested public repositories, default is 10 if not provided.
        :return: list[Repository]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_top_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.repositories_top_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def repositories_top_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get public repositories which are accessed most.  # noqa: E501

        This endpoint aims to let users see the most popular public repositories   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_top_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int count: The number of the requested public repositories, default is 10 if not provided.
        :return: list[Repository]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['count']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_top_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/top', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Repository]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_get(self, q, **kwargs):  # noqa: E501
        """Search for projects and repositories  # noqa: E501

        The Search endpoint returns information about the projects and repositories offered at public status or related to the current logged in user. The response includes the project and repository list in a proper display order.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_get(q, async=True)
        >>> result = thread.get()

        :param async bool
        :param str q: Search parameter for project and repository name. (required)
        :return: list[Search]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_get_with_http_info(q, **kwargs)  # noqa: E501
        else:
            (data) = self.search_get_with_http_info(q, **kwargs)  # noqa: E501
            return data

    def search_get_with_http_info(self, q, **kwargs):  # noqa: E501
        """Search for projects and repositories  # noqa: E501

        The Search endpoint returns information about the projects and repositories offered at public status or related to the current logged in user. The response includes the project and repository list in a proper display order.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_get_with_http_info(q, async=True)
        >>> result = thread.get()

        :param async bool
        :param str q: Search parameter for project and repository name. (required)
        :return: list[Search]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['q']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'q' is set
        if ('q' not in params or
                params['q'] is None):
            raise ValueError("Missing the required parameter `q` when calling `search_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Search]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def statistics_get(self, **kwargs):  # noqa: E501
        """Get projects number and repositories number relevant to the user  # noqa: E501

        This endpoint is aimed to statistic all of the projects number and repositories number relevant to the logined user, also the public projects number and repositories number. If the user is admin, he can also get total projects number and total repositories number.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.statistics_get(async=True)
        >>> result = thread.get()

        :param async bool
        :return: StatisticMap
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.statistics_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.statistics_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def statistics_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get projects number and repositories number relevant to the user  # noqa: E501

        This endpoint is aimed to statistic all of the projects number and repositories number relevant to the logined user, also the public projects number and repositories number. If the user is admin, he can also get total projects number and total repositories number.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.statistics_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: StatisticMap
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method statistics_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatisticMap',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def systeminfo_get(self, **kwargs):  # noqa: E501
        """Get general system info  # noqa: E501

        This API is for retrieving general system info, this can be called by anonymous request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.systeminfo_get(async=True)
        >>> result = thread.get()

        :param async bool
        :return: GeneralInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.systeminfo_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.systeminfo_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def systeminfo_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get general system info  # noqa: E501

        This API is for retrieving general system info, this can be called by anonymous request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.systeminfo_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: GeneralInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method systeminfo_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/systeminfo', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GeneralInfo',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def systeminfo_getcert_get(self, **kwargs):  # noqa: E501
        """Get default root certificate under OVA deployment.  # noqa: E501

        This endpoint is for downloading a default root certificate that only provides for admin user under OVA deployment.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.systeminfo_getcert_get(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.systeminfo_getcert_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.systeminfo_getcert_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def systeminfo_getcert_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get default root certificate under OVA deployment.  # noqa: E501

        This endpoint is for downloading a default root certificate that only provides for admin user under OVA deployment.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.systeminfo_getcert_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method systeminfo_getcert_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/systeminfo/getcert', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def systeminfo_volumes_get(self, **kwargs):  # noqa: E501
        """Get system volume info (total/free size).  # noqa: E501

        This endpoint is for retrieving system volume info that only provides for admin user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.systeminfo_volumes_get(async=True)
        >>> result = thread.get()

        :param async bool
        :return: SystemInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.systeminfo_volumes_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.systeminfo_volumes_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def systeminfo_volumes_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get system volume info (total/free size).  # noqa: E501

        This endpoint is for retrieving system volume info that only provides for admin user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.systeminfo_volumes_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: SystemInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method systeminfo_volumes_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/systeminfo/volumes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SystemInfo',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def targets_get(self, **kwargs):  # noqa: E501
        """List filters targets by name.  # noqa: E501

        This endpoint let user list filters targets by name, if name is nil, list returns all targets.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.targets_get(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: The replication's target name.
        :return: list[RepTarget]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.targets_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.targets_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def targets_get_with_http_info(self, **kwargs):  # noqa: E501
        """List filters targets by name.  # noqa: E501

        This endpoint let user list filters targets by name, if name is nil, list returns all targets.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.targets_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: The replication's target name.
        :return: list[RepTarget]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method targets_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/targets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RepTarget]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def targets_id_delete(self, id, **kwargs):  # noqa: E501
        """Delete specific replication&#39;s target.  # noqa: E501

        This endpoint is for to delete specific replication's target.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.targets_id_delete(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The replication's target ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.targets_id_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.targets_id_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def targets_id_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete specific replication&#39;s target.  # noqa: E501

        This endpoint is for to delete specific replication's target.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.targets_id_delete_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The replication's target ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method targets_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `targets_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/targets/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def targets_id_get(self, id, **kwargs):  # noqa: E501
        """Get replication&#39;s target.  # noqa: E501

        This endpoint is for get specific replication's target.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.targets_id_get(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The replication's target ID. (required)
        :return: RepTarget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.targets_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.targets_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def targets_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get replication&#39;s target.  # noqa: E501

        This endpoint is for get specific replication's target.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.targets_id_get_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The replication's target ID. (required)
        :return: RepTarget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method targets_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `targets_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/targets/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RepTarget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def targets_id_policies_get(self, id, **kwargs):  # noqa: E501
        """List the target relevant policies.  # noqa: E501

        This endpoint list policies filter with specific replication's target ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.targets_id_policies_get(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The replication's target ID. (required)
        :return: list[RepPolicy]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.targets_id_policies_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.targets_id_policies_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def targets_id_policies_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """List the target relevant policies.  # noqa: E501

        This endpoint list policies filter with specific replication's target ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.targets_id_policies_get_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The replication's target ID. (required)
        :return: list[RepPolicy]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method targets_id_policies_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `targets_id_policies_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/targets/{id}/policies/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RepPolicy]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def targets_id_put(self, id, repo_target, **kwargs):  # noqa: E501
        """Update replication&#39;s target.  # noqa: E501

        This endpoint is for update specific replication's target.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.targets_id_put(id, repo_target, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The replication's target ID. (required)
        :param PutTarget repo_target: Updates of replication's target. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.targets_id_put_with_http_info(id, repo_target, **kwargs)  # noqa: E501
        else:
            (data) = self.targets_id_put_with_http_info(id, repo_target, **kwargs)  # noqa: E501
            return data

    def targets_id_put_with_http_info(self, id, repo_target, **kwargs):  # noqa: E501
        """Update replication&#39;s target.  # noqa: E501

        This endpoint is for update specific replication's target.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.targets_id_put_with_http_info(id, repo_target, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The replication's target ID. (required)
        :param PutTarget repo_target: Updates of replication's target. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'repo_target']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method targets_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `targets_id_put`")  # noqa: E501
        # verify the required parameter 'repo_target' is set
        if ('repo_target' not in params or
                params['repo_target'] is None):
            raise ValueError("Missing the required parameter `repo_target` when calling `targets_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'repo_target' in params:
            body_params = params['repo_target']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/targets/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def targets_ping_post(self, target, **kwargs):  # noqa: E501
        """Ping validates target.  # noqa: E501

        This endpoint is for ping validates whether the target is reachable and whether the credential is valid.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.targets_ping_post(target, async=True)
        >>> result = thread.get()

        :param async bool
        :param PingTarget target: The target object. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.targets_ping_post_with_http_info(target, **kwargs)  # noqa: E501
        else:
            (data) = self.targets_ping_post_with_http_info(target, **kwargs)  # noqa: E501
            return data

    def targets_ping_post_with_http_info(self, target, **kwargs):  # noqa: E501
        """Ping validates target.  # noqa: E501

        This endpoint is for ping validates whether the target is reachable and whether the credential is valid.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.targets_ping_post_with_http_info(target, async=True)
        >>> result = thread.get()

        :param async bool
        :param PingTarget target: The target object. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['target']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method targets_ping_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'target' is set
        if ('target' not in params or
                params['target'] is None):
            raise ValueError("Missing the required parameter `target` when calling `targets_ping_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'target' in params:
            body_params = params['target']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/targets/ping', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def targets_post(self, reptarget, **kwargs):  # noqa: E501
        """Create a new replication target.  # noqa: E501

        This endpoint is for user to create a new replication target.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.targets_post(reptarget, async=True)
        >>> result = thread.get()

        :param async bool
        :param RepTargetPost reptarget: New created replication target. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.targets_post_with_http_info(reptarget, **kwargs)  # noqa: E501
        else:
            (data) = self.targets_post_with_http_info(reptarget, **kwargs)  # noqa: E501
            return data

    def targets_post_with_http_info(self, reptarget, **kwargs):  # noqa: E501
        """Create a new replication target.  # noqa: E501

        This endpoint is for user to create a new replication target.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.targets_post_with_http_info(reptarget, async=True)
        >>> result = thread.get()

        :param async bool
        :param RepTargetPost reptarget: New created replication target. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['reptarget']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method targets_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'reptarget' is set
        if ('reptarget' not in params or
                params['reptarget'] is None):
            raise ValueError("Missing the required parameter `reptarget` when calling `targets_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'reptarget' in params:
            body_params = params['reptarget']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/targets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def usergroups_get(self, **kwargs):  # noqa: E501
        """Get all user groups information  # noqa: E501

        Get all user groups information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.usergroups_get(async=True)
        >>> result = thread.get()

        :param async bool
        :return: list[UserGroup]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.usergroups_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.usergroups_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def usergroups_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get all user groups information  # noqa: E501

        Get all user groups information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.usergroups_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: list[UserGroup]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method usergroups_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/usergroups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[UserGroup]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def usergroups_group_id_delete(self, group_id, **kwargs):  # noqa: E501
        """Delete user group  # noqa: E501

        Delete user group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.usergroups_group_id_delete(group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.usergroups_group_id_delete_with_http_info(group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.usergroups_group_id_delete_with_http_info(group_id, **kwargs)  # noqa: E501
            return data

    def usergroups_group_id_delete_with_http_info(self, group_id, **kwargs):  # noqa: E501
        """Delete user group  # noqa: E501

        Delete user group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.usergroups_group_id_delete_with_http_info(group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method usergroups_group_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params or
                params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `usergroups_group_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/usergroups/{group_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def usergroups_group_id_get(self, group_id, **kwargs):  # noqa: E501
        """Get user group information  # noqa: E501

        Get user group information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.usergroups_group_id_get(group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_id: Group ID (required)
        :return: UserGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.usergroups_group_id_get_with_http_info(group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.usergroups_group_id_get_with_http_info(group_id, **kwargs)  # noqa: E501
            return data

    def usergroups_group_id_get_with_http_info(self, group_id, **kwargs):  # noqa: E501
        """Get user group information  # noqa: E501

        Get user group information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.usergroups_group_id_get_with_http_info(group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_id: Group ID (required)
        :return: UserGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method usergroups_group_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params or
                params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `usergroups_group_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/usergroups/{group_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserGroup',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def usergroups_group_id_put(self, group_id, **kwargs):  # noqa: E501
        """Update group information  # noqa: E501

        Update user group information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.usergroups_group_id_put(group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_id: Group ID (required)
        :param UserGroup usergroup:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.usergroups_group_id_put_with_http_info(group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.usergroups_group_id_put_with_http_info(group_id, **kwargs)  # noqa: E501
            return data

    def usergroups_group_id_put_with_http_info(self, group_id, **kwargs):  # noqa: E501
        """Update group information  # noqa: E501

        Update user group information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.usergroups_group_id_put_with_http_info(group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_id: Group ID (required)
        :param UserGroup usergroup:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'usergroup']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method usergroups_group_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params or
                params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `usergroups_group_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'usergroup' in params:
            body_params = params['usergroup']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/usergroups/{group_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def usergroups_post(self, **kwargs):  # noqa: E501
        """Create user group  # noqa: E501

        Create user group information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.usergroups_post(async=True)
        >>> result = thread.get()

        :param async bool
        :param UserGroup usergroup:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.usergroups_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.usergroups_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def usergroups_post_with_http_info(self, **kwargs):  # noqa: E501
        """Create user group  # noqa: E501

        Create user group information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.usergroups_post_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param UserGroup usergroup:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['usergroup']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method usergroups_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'usergroup' in params:
            body_params = params['usergroup']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/usergroups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_current_get(self, **kwargs):  # noqa: E501
        """Get current user info.  # noqa: E501

        This endpoint is to get the current user infomation.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_current_get(async=True)
        >>> result = thread.get()

        :param async bool
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.users_current_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.users_current_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def users_current_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get current user info.  # noqa: E501

        This endpoint is to get the current user infomation.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_current_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_current_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/current', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_get(self, **kwargs):  # noqa: E501
        """Get registered users of Harbor.  # noqa: E501

        This endpoint is for user to search registered users, support for filtering results with username.Notice, by now this operation is only for administrator.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_get(async=True)
        >>> result = thread.get()

        :param async bool
        :param str username: Username for filtering results.
        :param str email: Email for filtering results.
        :param int page: The page nubmer, default is 1.
        :param int page_size: The size of per page.
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.users_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.users_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def users_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get registered users of Harbor.  # noqa: E501

        This endpoint is for user to search registered users, support for filtering results with username.Notice, by now this operation is only for administrator.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str username: Username for filtering results.
        :param str email: Email for filtering results.
        :param int page: The page nubmer, default is 1.
        :param int page_size: The size of per page.
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['username', 'email', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'username' in params:
            query_params.append(('username', params['username']))  # noqa: E501
        if 'email' in params:
            query_params.append(('email', params['email']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[User]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_post(self, user, **kwargs):  # noqa: E501
        """Creates a new user account.  # noqa: E501

        This endpoint is to create a user if the user does not already exist.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_post(user, async=True)
        >>> result = thread.get()

        :param async bool
        :param User user: New created user. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.users_post_with_http_info(user, **kwargs)  # noqa: E501
        else:
            (data) = self.users_post_with_http_info(user, **kwargs)  # noqa: E501
            return data

    def users_post_with_http_info(self, user, **kwargs):  # noqa: E501
        """Creates a new user account.  # noqa: E501

        This endpoint is to create a user if the user does not already exist.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_post_with_http_info(user, async=True)
        >>> result = thread.get()

        :param async bool
        :param User user: New created user. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `users_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'user' in params:
            body_params = params['user']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_user_id_delete(self, user_id, **kwargs):  # noqa: E501
        """Mark a registered user as be removed.  # noqa: E501

        This endpoint let administrator of Harbor mark a registered user as be removed.It actually won't be deleted from DB.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_user_id_delete(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: User ID for marking as to be removed. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.users_user_id_delete_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.users_user_id_delete_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def users_user_id_delete_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Mark a registered user as be removed.  # noqa: E501

        This endpoint let administrator of Harbor mark a registered user as be removed.It actually won't be deleted from DB.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_user_id_delete_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: User ID for marking as to be removed. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_user_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `users_user_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_user_id_get(self, user_id, **kwargs):  # noqa: E501
        """Get a user&#39;s profile.  # noqa: E501

        Get user's profile with user id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_user_id_get(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Registered user ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.users_user_id_get_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.users_user_id_get_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def users_user_id_get_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get a user&#39;s profile.  # noqa: E501

        Get user's profile with user id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_user_id_get_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Registered user ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_user_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `users_user_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_user_id_password_put(self, user_id, password, **kwargs):  # noqa: E501
        """Change the password on a user that already exists.  # noqa: E501

        This endpoint is for user to update password. Users with the admin role can change any user's password. Guest users can change only their own password.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_user_id_password_put(user_id, password, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Registered user ID. (required)
        :param Password password: Password to be updated. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.users_user_id_password_put_with_http_info(user_id, password, **kwargs)  # noqa: E501
        else:
            (data) = self.users_user_id_password_put_with_http_info(user_id, password, **kwargs)  # noqa: E501
            return data

    def users_user_id_password_put_with_http_info(self, user_id, password, **kwargs):  # noqa: E501
        """Change the password on a user that already exists.  # noqa: E501

        This endpoint is for user to update password. Users with the admin role can change any user's password. Guest users can change only their own password.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_user_id_password_put_with_http_info(user_id, password, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Registered user ID. (required)
        :param Password password: Password to be updated. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'password']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_user_id_password_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `users_user_id_password_put`")  # noqa: E501
        # verify the required parameter 'password' is set
        if ('password' not in params or
                params['password'] is None):
            raise ValueError("Missing the required parameter `password` when calling `users_user_id_password_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'password' in params:
            body_params = params['password']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/password', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_user_id_put(self, user_id, profile, **kwargs):  # noqa: E501
        """Update a registered user to change his profile.  # noqa: E501

        This endpoint let a registered user change his profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_user_id_put(user_id, profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Registered user ID (required)
        :param UserProfile profile: Only email, realname and comment can be modified. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.users_user_id_put_with_http_info(user_id, profile, **kwargs)  # noqa: E501
        else:
            (data) = self.users_user_id_put_with_http_info(user_id, profile, **kwargs)  # noqa: E501
            return data

    def users_user_id_put_with_http_info(self, user_id, profile, **kwargs):  # noqa: E501
        """Update a registered user to change his profile.  # noqa: E501

        This endpoint let a registered user change his profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_user_id_put_with_http_info(user_id, profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Registered user ID (required)
        :param UserProfile profile: Only email, realname and comment can be modified. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'profile']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_user_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `users_user_id_put`")  # noqa: E501
        # verify the required parameter 'profile' is set
        if ('profile' not in params or
                params['profile'] is None):
            raise ValueError("Missing the required parameter `profile` when calling `users_user_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'profile' in params:
            body_params = params['profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_user_id_sysadmin_put(self, user_id, has_admin_role, **kwargs):  # noqa: E501
        """Update a registered user to change to be an administrator of Harbor.  # noqa: E501

        This endpoint let a registered user change to be an administrator of Harbor.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_user_id_sysadmin_put(user_id, has_admin_role, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Registered user ID (required)
        :param HasAdminRole has_admin_role: Toggle a user to admin or not. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.users_user_id_sysadmin_put_with_http_info(user_id, has_admin_role, **kwargs)  # noqa: E501
        else:
            (data) = self.users_user_id_sysadmin_put_with_http_info(user_id, has_admin_role, **kwargs)  # noqa: E501
            return data

    def users_user_id_sysadmin_put_with_http_info(self, user_id, has_admin_role, **kwargs):  # noqa: E501
        """Update a registered user to change to be an administrator of Harbor.  # noqa: E501

        This endpoint let a registered user change to be an administrator of Harbor.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_user_id_sysadmin_put_with_http_info(user_id, has_admin_role, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Registered user ID (required)
        :param HasAdminRole has_admin_role: Toggle a user to admin or not. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'has_admin_role']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_user_id_sysadmin_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `users_user_id_sysadmin_put`")  # noqa: E501
        # verify the required parameter 'has_admin_role' is set
        if ('has_admin_role' not in params or
                params['has_admin_role'] is None):
            raise ValueError("Missing the required parameter `has_admin_role` when calling `users_user_id_sysadmin_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'has_admin_role' in params:
            body_params = params['has_admin_role']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/sysadmin', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
